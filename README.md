# funcscope
## 项目简介

funcscope 是一个 **函数级 / 代码片段级执行耗时采集工具**，面向 **x86 与 ARM V8 平台**，通过源码插桩精确测量执行时间。

它并非通用 Profiler，而是用于 **量化优化效果与验证性能回归** 的低侵入度量工具。  

funcscope 在函数入口/出口记录时间差，并写入每函数独立缓冲区，实现 **零锁、零系统调用** 的热路径采集。  

统计逻辑与业务代码解耦，由独立工具周期性读取并计算分布数据。  

与 perf 的采样模型不同，funcscope 提供 **确定性的单次调用耗时数据**。 
 
适用于网络代理、协议栈、事件驱动程序等高频性能敏感场景。

## 能力边界与限制说明

funcscope 的设计目标是以**极低侵入性**量化函数或代码片段的执行耗时，因此在能力范围上做了明确取舍：

### 支持的场景

- 函数级或代码片段级的执行耗时测量  
- 高频调用路径中的微优化效果量化  
- 优化前 / 优化后的耗时对比与性能回归验证  
- 偶发慢路径（尾部延迟）的分布分析  
- UDP / 网络代理 / 协议栈 / 事件驱动程序等性能敏感场景  
- x86（RDTSC）与 ARM V8（CNTVCT）平台

### 不支持的场景

- **递归函数**  
  插桩模型基于成对的进入 / 退出记录，递归调用会破坏统计语义。

- **线程调度或线程级分析**  
  funcscope 不感知线程切换，不用于分析锁竞争、上下文切换等问题。

- **自动热点定位**  
  该工具不会像 perf 一样自动发现热点函数，需要由开发者明确指定测量边界。

- **跨函数调用栈分析**  
  funcscope 仅关注单个函数或代码片段的执行耗时，不构建调用栈关系。

### 设计取舍说明

funcscope 有意避免在热路径中引入原子操作、锁或系统调用，  
以换取 **更低的运行时干扰** 和 **更清晰的统计语义**。  
因此它更适合作为性能优化过程中的 **量化与验证工具**，而不是全自动性能分析器。


## 一、funcscope 是做什么的

funcscope 解决的问题很明确：

> **我已经知道“要看哪段代码”，只想知道它真实跑了多久，并且不想引入重型工具。**

它的核心能力包括：

- 对 **函数整体执行时间** 进行统计
- 对 **函数内部某一段代码 scope** 进行统计
- 支持 **高频调用路径**（百万 / 千万级调用）
- 运行期开销可控，不依赖采样或内核事件

典型使用方式：

```c
FUNC_SCOPE_ENTER(id);
/* hot path or critical section */
FUNC_SCOPE_EXIT(id);
```

或：

```c
FUNC_SCOPE_BEGIN(id);
/* part A */
FUNC_SCOPE_END(id);
```

---

## 二、funcscope 不是什么（能力边界）

funcscope **刻意不做** 以下事情：

- ❌ 不是 profiler（不采样、不统计调用栈）
- ❌ 不生成火焰图
- ❌ 不分析 cache miss / branch miss
- ❌ 不做线程级 / CPU 级归因
- ❌ 不支持递归函数

如果你的问题是：

- “CPU 时间都花到哪里去了？”
- “哪个函数最热？”

👉 **请直接使用 perf / bpftrace**，funcscope 不适合。

---

## 三、funcscope 适合的场景

funcscope 适合在以下场景中使用：

### 1. 已定位函数后的精确度量

例如：

- perf 已经定位到 `ngx_stream_proxy_process`
- 你想知道：
  - 整个函数一次调用真实耗时
  - 函数内部某个分支 / 拷贝逻辑耗时

funcscope 可以直接在源码中给出**明确边界**。

---

### 2. 高频路径下的回归验证

- 热路径函数被调用 1e7 次 / 秒
- 改了一行代码
- 只想确认 **平均耗时是否发生变化**

funcscope 适合用于：

- 性能回归检测
- 热路径微优化验证

---

### 3. 替代零散的 clock_gettime 插桩

相比在代码中散落大量：

```c
clock_gettime(...);
```

funcscope：

- 统一接口
- 统一数据结构
- 可集中统计与输出

---

## 四、不适合使用 funcscope 的场景

以下场景 **明确不建议** 使用 funcscope：

- 想分析整个系统的性能分布
- 想知道 cache miss 是哪条指令导致的
- 想做线程调度 / NUMA / TLB 分析
- 想分析递归调用链

这些问题 **必须使用 perf / bpftrace / VTune 等工具**。

---

## 五、与 perf / bpftrace 的关系

funcscope **不是 perf 的替代品**，而是补充。

| 工具 | 擅长 | 不擅长 |
|----|----|----|
| perf | 全局热点、cache miss、指令级分析 | 精确源码边界 |
| bpftrace | 动态追踪、低侵入 | 高频、源码内细粒度 |
| funcscope | 已知代码位置的精确耗时 | 全局分析 |

推荐流程：

1. 使用 perf 定位热点函数
2. 使用 perf annotate / 源码分析缩小范围
3. 使用 funcscope **在源码中精确度量关键路径**

---

## 六、核心实现思路（概览）

funcscope 的设计遵循几个明确原则：

- **时间获取必须足够快**
  - x86：TSC
  - ARM V8：高精度单调时钟

- **不在热路径中做统计计算**
  - 热路径只记录时间差
  - 统计与聚合在独立阶段完成

- **空间与时间可预测**
  - 固定大小数组
  - 不动态扩容

- **避免额外 cache 抖动**
  - 单写者模型
  - 批量读取与统计

---

## 七、设计约束（必须遵守）

- 单次测量的执行时间 **必须 < 1 秒**
- 时间差值使用整数存储
- 每个统计点独立维护数据
- 不支持递归函数
- 不保证跨线程一致性

---

## 八、支持的平台

- Linux x86_64
- Linux ARM64

---

## 九、总结一句话

> **funcscope 是一个面向“已知代码位置”的源码级耗时度量工具。**
> 
> 它不试图回答“哪里慢”，而是回答：
> 
> **“这段代码，真实跑了多久。”**

